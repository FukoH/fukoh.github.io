---
title: 'TCP/IP笔记'
date: 2021-02-01
permalink: /posts/2020/08/TCP/IP笔记/
tags:
  - NetWorking
---


# 第1章 概述
## 1.2 分层

1. 链路层。也称数据链路层或网络接口层，包括设备驱动程序和网络接口卡，它们一起处理与电缆的物理接口细节。
2. 网络层。处理分组在网络中的活动，如分组的选路；网络层的协议包括IP协议、ICMP协议（Internet互联网控制报文协议）、IGMP协议（Internet组管理协议）。
3. 传输层。主要为两台主机上的应用程序提供端到端的通信，包括TCP（传输控制协议）和UDP（用户数据报协议）。
4. 应用层。处理特定的应用程序细节。
## 1.3 TCP/IP分层
![](https://images2015.cnblogs.com/blog/37882/201510/37882-20151003232315105-1052171064.png)
## 1.4 网络IP分类
![](https://images2015.cnblogs.com/blog/37882/201510/37882-20151003232315355-347339440.png)

![](https://images2015.cnblogs.com/blog/37882/201510/37882-20151003232315605-831992070.png)

#第2章 链路层
## 2.1 引言
链路层目的

- 为IP模块发送和接收IP数据报
- 为ARP模块发送ARP请求和接收ARP应答
- 为RARP发送RARP请求和接收RARP应答

(ARP叫做地址解析协议，是用IP地址换MAC地址的一种协议RARP则叫做逆地址解析协议)

-
## 2.2 链路层的传销接口链路层协议

ppp(点对点协议)是从SLIP的替代品。他们都提供了一种低速接入的解决方案。而每一种数据链路层协议，都有一个MTU（最大传输单元）定义，在这个定义下面，如果IP数据报过大，则要进行分片(fragmentation)，使得每片都小于MTU，注意PPP的MTU并不是一个物理定义，而是指一个逻辑定义（个人认为就是用程序控制）。可以用netstat来打印出MTU的结果，比如键入netstat -in：

Kernel Interface table
Iface      MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0      1500  0    1774     0     0     0     587     0     0     0 BMRU
lo       16436  0    2667     0     0     0    2667     0     0     0 LRU

 就可以观察到eth0的MTU是1500。而lo（环回接口）的MTU则是16436。

## 2.3 环回接口
 最后说说那个环回接口（loopback）。平时我们用127.0.0.1来尝试自己的机器服务器好使不好使。走的就是这个loopback接口。对于环回接口，有如下三点值得注意:
- 传给环回地址（一般是127.0.0.1）的任何数据均作为I P输入。
- 传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是 因为广播传送和多播传送的定义包含主机本身。
- 任何传给该主机IP地址的数据均送到环回接口。

## MTU
数据帧长度的限制，是一个逻辑限制，目的是为交互使用提供足够的响应时间。

# 第3章 IP:网际协议

# 第17章 TCP:传输控制协议
第17章 TCP：传输控制协议

## 17.1 TCP服务

尽管TCP和UDP都使用相同的网络层（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。

### 17.1.1 面向连接

两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。过程与打电话相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。

说明：在一个TCP连接中，仅有两方彼此进行通信。广播和多播不能用于TCP。

### 17.1.2 可靠性

TCP通过下列方式来提供可靠性：

- 应用数据被分割成TCP认为最适合发送的数据块。由TCP传递给IP的信息单位称为报文段或段。

注意：对于UDP，应用程序产生的数据报长度将保持不变。

- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

- 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。

- TCP将保持它的首部和数据检验和。这是一个端到端的检验和，如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。

- 因为TCP报文段是作为IP数据报来传输的，而IP数据报的到达可能会失序，所以TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。

- 因为IP数据报会发生重复，所以TCP的接收端必须丢弃重复的数据。

- TCP提供流量控制。TCP连接的每一方都有固定大小的缓冲区。TCP的接收端只允许另一端发送其缓冲区所能接纳的数据。可防止较快主机致使较慢主机的缓冲区溢出。

说明：

1）两个应用程序通过TCP连接交换8 bit构成的字节流。TCP不在字节流中插入记录标识符。将这称为字节流服务。

2）假设一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。

3）TCP对字节流的内容不作任何解释，它不知道传输的数据字节流是二进制数据、ASCII字符、EBCDIC字符或其他类型数据。由TCP双方的应用层对字节流进行解释。

 

2、TCP首部

TCP数据被封装在一个IP数据报中，如图17-1所示。
![](https://images0.cnblogs.com/blog2015/697266/201504/221940145468929.png)


图17-2显示TCP首部的数据格式。如果不计选项字段，它通常是20个字节。
![](https://images0.cnblogs.com/blog2015/697266/201504/221941291718831.png)


TCP首部字段说明：

（1）TCP段包含的源端和目的端端口号，是用于寻找发端和收端应用进程。

说明：源端和目的端端口号加上源端IP地址和目的端IP地址唯一确定一个TCP连接。

（2）序号用来标识从TCP发端向收端发送的数据字节流。如果将字节流看作是在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32 bit的无符号数，到达2^32-1后又从0开始。

说明：TCP为应用层提供全双工服务。这意味着数据能在两个方向上独立进行传输。所以，连接的每一端必须保持每个方向上的传输数据序号。

（3）当建立一个新的连接时，SYN标志置1。

（4）因为每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号，即确认序号是上次已成功收到数据字节序号加1。

注意：只有ACK标志为1时确认序号字段才有效。

（5）发送ACK无需任何代价，因为32 bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。

（6）首部长度给出首部中32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此TCP最多有60字节的首部（32bit*(2^4-1)）。如果没有选项字段，正常的长度是20字节。

（7）TCP首部中有6个标志比特，它们中的多个可同时被设置为1。含义为：

1）URG 紧急指针有效。

2）ACK 确认序号有效。

3）PSH 接收方应该尽快将这个报文段交给应用层。

4）RST 重建连接。

5）SYN 同步序号用来发起一个连接。

6）FIN 发端完成发送任务。

（8）TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个16 bit字段，因而窗口大小最大为65535字节。

（9）检验和覆盖了整个TCP报文段包括TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。

说明：TCP检验和的计算与UDP检验和的计算相似，使用一个伪首部。

（10）只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。

（11）最常见的选项字段是最长报文大小，又称为MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

（12）TCP报文段中的数据部分是可选的。例如：一个连接建立和终止时，双方交换的报文段仅有TCP首部。在处理超时的许多情况中，也会发送不带任何数据的报文段。

 

小结：

（1）TCP提供了一种可靠的面向连接的字节流运输层服务。

（2）TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。

（3）许多流行的应用程序如Telnet、Rlogin、FTP和SMTP都使用TCP。

 

# 第18章 TCP连接的建立与终止

## 1、引言

TCP是一个面向连接的协议。无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。

## 2、连接的建立与终止

（1）建立连接协议

如果18-3所示，为了建立一条TCP连接：

![](https://images0.cnblogs.com/blog2015/697266/201504/222117276092162.png)


1）请求端（客户）发送一个SYN段指明客户打算连接的服务器的端口，以及初始序号（ISN，例子中为1415531521），如报文1。

2）服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。

3）客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。

这三个报文段完成连接的建立，这个过程也称为三次握手。

说明：

1）发送第一个SYN的一端将执行主动打开，接收这个SYN并发回下一个SYN的另一端执行被动打开。

2）当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。

（2）终止连接

终止一个连接要经过4次握手。这是由TCP的半关闭造成的。

说明：

1）因为TCP是全双工的（数据在两个方向上能同时传递），因此每个方向必须单独进行关闭。原则是：当一方完成它的数据发送任务后发送一个FIN来终止这个方向连接。当一端收到一个FIN时，它必须通知应用层另一端已经终止了那个方向的数据传送。

注意：发送FIN通常是应用层进行关闭的结果。

2）收到一个FIN只意味着在这一方向上没有数据流动。

注意：一个TCP连接在收到一个FIN后仍能发送数据，这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的TCP应用程序这样做。

图18-4显示了终止一个连接的典型握手顺序。

![](https://images0.cnblogs.com/blog2015/697266/201504/222146082184141.png)

发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的。

##3.  建立连接的超时
- 重传机制，采用一种500ms的定时器，初始为12个定时器（6秒），当12个都为0时，发出一个新的TCP请求，还是超时，初始化48个定时器（24秒）
## 4. 最大报文长度
不同设备的MTU不一样，有一个协商的过程：
![](https://img-blog.csdn.net/20160403234524091)
路径MTU发现的基本思想是源主机最初假设到目的主机的路径MTU为源主机发送这个报文的第一跳接口的MTU，并把发送到主机的所有IP报文的IP头中的DF位置一。在这个转发路径中的某个路由器收到某个报文，要从某个出接口出去的时候发现该报文大于出接口的MTU，并且其FD位4为1，该路由器将会丢弃本报文，并且返回一个ICMP目的地址不可达报文通知被丢弃报文的源主机，源主机收到这个ICMP报文后就减小假定的这条路径上的PMTU值。

最大报文段长度表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。它是一个可“协商”选项，当建立一个连接是，每一方都有用于通告它期望接收的MSS选项。而且在协商过后，该选项内容可以改变，也可以没有。在协商MSS时，一般是建立TCP连接的两端发送【SYN】标志报文时互相通报，然后选取最小MSS作为双方的约定。如果双方都不通报，或有一方不通报，一般选择MSS的默认值536.
## 5. TCP的半关闭
因为数据传输是双向的，采用半关闭可以在一端关闭时，另一端继续传输
## 6.  2msl等待
在四次挥手时，由于第三次挥手时，如果客户端的消息丢失，服务端不知道客户端有没有收到服务端的消息，分为两种情况：收到了，但是第四次的消息丢失和根本没收到，所以客户端会等待2msl的时间，通常为30秒，1min或2min。这个期间同一个socket不会被其他应用占据。这段时间被称为平静时间
## 7. 复位报文段
TCP首部中的RST比特用户复位。UDP在到达目的端口时，会茶农一个ICMP不可达信息。TCP则使用复位。
使用telnet测试会发现，第一个报文和三次握手中第一次SYN置1的报文一样，但是返回的报文则是ACK没有被置1，复位报文段的序号被置为0。
## 8.异常终止链接
异常终止一个连接，如果本端发生异常，无法正常关闭(发送fin消息)，则只能发送rst消息。这样做有2个好处，本端丢弃未发送的数据；rst接收方可以区分是正常关闭还是异常关闭。
使用rst的时候，服务端会收到”connection rest by peer的提示“
## 9. 检测半打开的链接
检测半打开连接，比如服务端已经关闭(异常关闭，如机器重启，或fin消息丢掉)，而客户端并不知道服务端已经关闭，所以这个时候，客户端则处于半打开连接，如果这个时候客户端又向服务端发送数据，由于服务端已经断开连接(如重启机器)，并不知道这个数据从哪来的，先前没有经过3次握手建立连接，则只能回复rst消息，告知客户端异常关闭。客户端会收到“Connection closed by foreign host"
## 10. 同时打开
如果两端同时打开，则会发送4个报文，并且知道这是同一个socket。此时不再区分服务端和客户端。
![](https://img-my.csdn.net/uploads/201210/30/1351592710_8294.JPG)
## 11. 同时关闭
![](https://img-my.csdn.net/uploads/201210/30/1351592761_9080.JPG)
同样发送4个报文
##12. TCP选项
##13. TCP服务器
- TCP服务器的端口号
    netstat -a -n -f inet
可以查看 所有（-a)的 点十分位（-n)显示的使用TCP、UDP的（-f inet)主机
可以看到，要是有同时连接到服务器的连接，他们的foreign address的端口是不一样的。也即是说，socket是个四元组，由于端口号不同，不会发生冲突。
## 14.呼入连接请求队列
三次握手成功是个及时操作，系统不可能紧盯着它等处理。那服务器繁忙时，有连接到了怎么办？很简单，排队，等有空了挨个处理。

　　“呼入请求队列”便是这个。需要注意的：客户端connect成功，仅仅只表示被放入了svr的呼入请求队列（此时client仍能发数据，收的数据被放在tcp缓存了），还未交接给应用层。svr端Accept时才会将队列中的连接取出，进而处理。

　　PS：如果不取或取慢了，client会因tcp发送缓冲满而一直send失败。所以怎么调Accept也是要考虑设计的

　　PPS：“呼入请求队列”有长度限制（积压值 backlog），超过后再来的连接请求就一直失败了。
# 19章 TCP的交互数据流

有关TCP通信量的研究发现：按分组数量计算，约有一半的TCP报文段包含成块数据（如FTP、电子邮件和Usenet新闻），另一半则包含交互数据（如Telnet和Rlogin）。按字节计算，成块数据与交互数据的比例约为90%和10%。

成块数据的报文段基本上都是满长度的（通常为512字节的用户数据），交互数据则小得多（Telnet和Rlogin分组中约90%左右的用户数据小于10个字节）

TCP需要同时处理这两类数据，但使用的处理算法不同。

[参考笔记](!https://blog.csdn.net/weixin_33701251/article/details/93315311)

## 滑动窗口协议
### 工作原理
![](https://img2020.cnblogs.com/blog/1366679/202009/1366679-20200910072426785-2116653367.png)
为什么要滑动窗口：
提高传输效率
### 如何改进滑动窗口协议
SR协议：在收取方也添加缓存机制，通过窗口批量返回和交给上层

## TCP如何提供可靠服务
- 流水线机制
- 重传机制
- 单一重传定时器

##如何设置重传时间？
- 大于RTT
但是RTT不是常量
- 使用移动加权法计算RTT
先观测sampleRTT,然后计算estimatedRTT
$$ estinatedrtt = (1 - alpha) * estimatedRTT + appha * sampleRTT$$
典型值：0.125